xrun(64): 18.09-s011: (c) Copyright 1995-2019 Cadence Design Systems, Inc.
TOOL:	xrun(64)	18.09-s011: Started on Dec 06, 2021 at 20:53:02 CST
xrun
	-64bit
	-gui
	-access r
	cpu.v
	cpu_tb.v
Recompiling... reason: file './cpu_tb.v' is newer than expected.
	expected: Mon Dec  6 20:31:57 2021
	actual:   Mon Dec  6 20:52:57 2021
file: cpu.v
        1'h2 : hex = 1;
           |
xmvlog: *W,INTOVF (lib/syncram.v,45|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/syncram.v line 45, `include file: d_mem.v line 2, file: cpu.v line 7)
        1'h3 : hex = 1;
           |
xmvlog: *W,INTOVF (lib/syncram.v,46|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/syncram.v line 46, `include file: d_mem.v line 2, file: cpu.v line 7)
        1'h4 : hex = 1;
           |
xmvlog: *W,INTOVF (lib/syncram.v,47|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/syncram.v line 47, `include file: d_mem.v line 2, file: cpu.v line 7)
        1'h5 : hex = 1;
           |
xmvlog: *W,INTOVF (lib/syncram.v,48|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/syncram.v line 48, `include file: d_mem.v line 2, file: cpu.v line 7)
        1'h6 : hex = 1;
           |
xmvlog: *W,INTOVF (lib/syncram.v,49|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/syncram.v line 49, `include file: d_mem.v line 2, file: cpu.v line 7)
        1'h7 : hex = 1;
           |
xmvlog: *W,INTOVF (lib/syncram.v,50|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/syncram.v line 50, `include file: d_mem.v line 2, file: cpu.v line 7)
        1'h8 : hex = 1;
           |
xmvlog: *W,INTOVF (lib/syncram.v,51|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/syncram.v line 51, `include file: d_mem.v line 2, file: cpu.v line 7)
        1'h9 : hex = 1;
           |
xmvlog: *W,INTOVF (lib/syncram.v,52|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/syncram.v line 52, `include file: d_mem.v line 2, file: cpu.v line 7)
        1'ha : hex = 1;
           |
xmvlog: *W,INTOVF (lib/syncram.v,53|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/syncram.v line 53, `include file: d_mem.v line 2, file: cpu.v line 7)
        1'hb : hex = 1;
           |
xmvlog: *W,INTOVF (lib/syncram.v,54|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/syncram.v line 54, `include file: d_mem.v line 2, file: cpu.v line 7)
        1'hc : hex = 1;
           |
xmvlog: *W,INTOVF (lib/syncram.v,55|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/syncram.v line 55, `include file: d_mem.v line 2, file: cpu.v line 7)
        1'hd : hex = 1;
           |
xmvlog: *W,INTOVF (lib/syncram.v,56|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/syncram.v line 56, `include file: d_mem.v line 2, file: cpu.v line 7)
        1'he : hex = 1;
           |
xmvlog: *W,INTOVF (lib/syncram.v,57|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/syncram.v line 57, `include file: d_mem.v line 2, file: cpu.v line 7)
        1'hf : hex = 1;
           |
xmvlog: *W,INTOVF (lib/syncram.v,58|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/syncram.v line 58, `include file: d_mem.v line 2, file: cpu.v line 7)
        1'hA : hex = 1;
           |
xmvlog: *W,INTOVF (lib/syncram.v,59|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/syncram.v line 59, `include file: d_mem.v line 2, file: cpu.v line 7)
        1'hB : hex = 1;
           |
xmvlog: *W,INTOVF (lib/syncram.v,60|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/syncram.v line 60, `include file: d_mem.v line 2, file: cpu.v line 7)
        1'hC : hex = 1;
           |
xmvlog: *W,INTOVF (lib/syncram.v,61|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/syncram.v line 61, `include file: d_mem.v line 2, file: cpu.v line 7)
        1'hD : hex = 1;
           |
xmvlog: *W,INTOVF (lib/syncram.v,62|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/syncram.v line 62, `include file: d_mem.v line 2, file: cpu.v line 7)
        1'hE : hex = 1;
           |
xmvlog: *W,INTOVF (lib/syncram.v,63|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/syncram.v line 63, `include file: d_mem.v line 2, file: cpu.v line 7)
        1'hF : hex = 1;
           |
xmvlog: *W,INTOVF (lib/syncram.v,64|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/syncram.v line 64, `include file: d_mem.v line 2, file: cpu.v line 7)
        initiate();
                 |
xmvlog: *W,TMTPAR (lib/syncram.v,172|17): A task enable with no arguments must not include an empty set of parentheses [10.2.2 (IEEE Std 1364-2005)].  The compiler has ignored the parentheses.  Use 'xmhelp xmvlog TMTPAR'  for further information.
(`include file: lib/syncram.v line 172, `include file: d_mem.v line 2, file: cpu.v line 7)
        checkRAM();
                 |
xmvlog: *W,TMTPAR (lib/syncram.v,177|17): A task enable with no arguments must not include an empty set of parentheses [10.2.2 (IEEE Std 1364-2005)].  The compiler has ignored the parentheses.  Use 'xmhelp xmvlog TMTPAR'  for further information.
(`include file: lib/syncram.v line 177, `include file: d_mem.v line 2, file: cpu.v line 7)
	module worklib.set_if_eq:v
		errors: 0, warnings: 0
        1'h2 : hex = 1;
           |
xmvlog: *W,INTOVF (lib/sram.v,44|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/sram.v line 44, `include file: inst_mem.v line 2, file: cpu.v line 10)
        1'h3 : hex = 1;
           |
xmvlog: *W,INTOVF (lib/sram.v,45|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/sram.v line 45, `include file: inst_mem.v line 2, file: cpu.v line 10)
        1'h4 : hex = 1;
           |
xmvlog: *W,INTOVF (lib/sram.v,46|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/sram.v line 46, `include file: inst_mem.v line 2, file: cpu.v line 10)
        1'h5 : hex = 1;
           |
xmvlog: *W,INTOVF (lib/sram.v,47|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/sram.v line 47, `include file: inst_mem.v line 2, file: cpu.v line 10)
        1'h6 : hex = 1;
           |
xmvlog: *W,INTOVF (lib/sram.v,48|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/sram.v line 48, `include file: inst_mem.v line 2, file: cpu.v line 10)
        1'h7 : hex = 1;
           |
xmvlog: *W,INTOVF (lib/sram.v,49|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/sram.v line 49, `include file: inst_mem.v line 2, file: cpu.v line 10)
        1'h8 : hex = 1;
           |
xmvlog: *W,INTOVF (lib/sram.v,50|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/sram.v line 50, `include file: inst_mem.v line 2, file: cpu.v line 10)
        1'h9 : hex = 1;
           |
xmvlog: *W,INTOVF (lib/sram.v,51|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/sram.v line 51, `include file: inst_mem.v line 2, file: cpu.v line 10)
        1'ha : hex = 1;
           |
xmvlog: *W,INTOVF (lib/sram.v,52|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/sram.v line 52, `include file: inst_mem.v line 2, file: cpu.v line 10)
        1'hb : hex = 1;
           |
xmvlog: *W,INTOVF (lib/sram.v,53|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/sram.v line 53, `include file: inst_mem.v line 2, file: cpu.v line 10)
        1'hc : hex = 1;
           |
xmvlog: *W,INTOVF (lib/sram.v,54|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/sram.v line 54, `include file: inst_mem.v line 2, file: cpu.v line 10)
        1'hd : hex = 1;
           |
xmvlog: *W,INTOVF (lib/sram.v,55|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/sram.v line 55, `include file: inst_mem.v line 2, file: cpu.v line 10)
        1'he : hex = 1;
           |
xmvlog: *W,INTOVF (lib/sram.v,56|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/sram.v line 56, `include file: inst_mem.v line 2, file: cpu.v line 10)
        1'hf : hex = 1;
           |
xmvlog: *W,INTOVF (lib/sram.v,57|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/sram.v line 57, `include file: inst_mem.v line 2, file: cpu.v line 10)
        1'hA : hex = 1;
           |
xmvlog: *W,INTOVF (lib/sram.v,58|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/sram.v line 58, `include file: inst_mem.v line 2, file: cpu.v line 10)
        1'hB : hex = 1;
           |
xmvlog: *W,INTOVF (lib/sram.v,59|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/sram.v line 59, `include file: inst_mem.v line 2, file: cpu.v line 10)
        1'hC : hex = 1;
           |
xmvlog: *W,INTOVF (lib/sram.v,60|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/sram.v line 60, `include file: inst_mem.v line 2, file: cpu.v line 10)
        1'hD : hex = 1;
           |
xmvlog: *W,INTOVF (lib/sram.v,61|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/sram.v line 61, `include file: inst_mem.v line 2, file: cpu.v line 10)
        1'hE : hex = 1;
           |
xmvlog: *W,INTOVF (lib/sram.v,62|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/sram.v line 62, `include file: inst_mem.v line 2, file: cpu.v line 10)
        1'hF : hex = 1;
           |
xmvlog: *W,INTOVF (lib/sram.v,63|11): bit overflow during conversion from text [2.5(IEEE)] (1 bits).
(`include file: lib/sram.v line 63, `include file: inst_mem.v line 2, file: cpu.v line 10)
        initiate();
                 |
xmvlog: *W,TMTPAR (lib/sram.v,171|17): A task enable with no arguments must not include an empty set of parentheses [10.2.2 (IEEE Std 1364-2005)].  The compiler has ignored the parentheses.  Use 'xmhelp xmvlog TMTPAR'  for further information.
(`include file: lib/sram.v line 171, `include file: inst_mem.v line 2, file: cpu.v line 10)
        checkRAM();
                 |
xmvlog: *W,TMTPAR (lib/sram.v,176|17): A task enable with no arguments must not include an empty set of parentheses [10.2.2 (IEEE Std 1364-2005)].  The compiler has ignored the parentheses.  Use 'xmhelp xmvlog TMTPAR'  for further information.
(`include file: lib/sram.v line 176, `include file: inst_mem.v line 2, file: cpu.v line 10)
module set_if_eq(x, y, z);
               |
xmvlog: *W,RECOME (cpu.v,350|15): recompiling design unit worklib.set_if_eq:v.
	First compiled from line 34 of stall.v.
	module worklib.set_if_eq:v
		errors: 0, warnings: 1
file: cpu_tb.v
	module worklib.nostalls_tb:v
		errors: 0, warnings: 0
		Caching library 'worklib' ....... Done
	Elaborating the design hierarchy:
		Caching library 'worklib' ....... Done
	Top level design units:
		pc_branch
		read_0
		hazard_detected
		unsigned_sum_tb
		sort_correct_branch_tb
		bills_branch_tb
		nostalls_tb
xmelab: *W,DSEMEL: This SystemVerilog design will be simulated as per IEEE 1800-2009 SystemVerilog simulation semantics. Use -disable_sem2009 option for turning off SV 2009 simulation semantics.
	d_mem datamem(.clk(clk), .data_in(busB), .data_out(DataOut), .adr(ALUout), .WrEn(MemMemWr));
	                                     |
xmelab: *W,CUVMPW (./cpu.v,134|38): port sizes differ in port connection (1/32).
	mux_32 datamux({31'b0, WrMemToReg}, WrALUout, WrDataOut, busW);
	                                                            |
xmelab: *W,CUVMPW (./cpu.v,136|61): port sizes differ in port connection (1/32).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                   |
xmelab: *W,CUVMPW (./cpu.v,137|132): port sizes differ in port connection (1/5).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                                  |
xmelab: *W,CUVMPW (./cpu.v,137|147): port sizes differ in port connection (1/5).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                                                        |
xmelab: *W,CUVMPW (./cpu.v,137|169): port sizes differ in port connection (5/1).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                                                                     |
xmelab: *W,CUVMPW (./cpu.v,137|182): port sizes differ in port connection (5/1).
	set_if_eq eqRsEX (.x(Rs), .y(EXrw), .z(dhaz[3]));
	                      |
xmelab: *W,CUVMPW (./stall.v,18|23): port sizes differ in port connection (1/6).
	set_if_eq eqRsEX (.x(Rs), .y(EXrw), .z(dhaz[3]));
	                                |
xmelab: *W,CUVMPW (./stall.v,18|33): port sizes differ in port connection (5/6).
	set_if_eq eqRsWr (.x(Rs), .y(Wrrw), .z(dhaz[2]));
	                      |
xmelab: *W,CUVMPW (./stall.v,19|23): port sizes differ in port connection (1/6).
	set_if_eq eqRsWr (.x(Rs), .y(Wrrw), .z(dhaz[2]));
	                                |
xmelab: *W,CUVMPW (./stall.v,19|33): port sizes differ in port connection (5/6).
	set_if_eq eqRtEX (.x(IDRt), .y(EXrw), .z(dhaz[1]));
	                        |
xmelab: *W,CUVMPW (./stall.v,20|25): port sizes differ in port connection (1/6).
	set_if_eq eqRtEX (.x(IDRt), .y(EXrw), .z(dhaz[1]));
	                                  |
xmelab: *W,CUVMPW (./stall.v,20|35): port sizes differ in port connection (5/6).
	set_if_eq eqRtWr (.x(IDRt), .y(Wrrw), .z(dhaz[0]));
	                        |
xmelab: *W,CUVMPW (./stall.v,21|25): port sizes differ in port connection (1/6).
	set_if_eq eqRtWr (.x(IDRt), .y(Wrrw), .z(dhaz[0]));
	                                  |
xmelab: *W,CUVMPW (./stall.v,21|35): port sizes differ in port connection (5/6).
	d_mem datamem(.clk(clk), .data_in(busB), .data_out(DataOut), .adr(ALUout), .WrEn(MemMemWr));
	                                     |
xmelab: *W,CUVMPW (./cpu.v,134|38): port sizes differ in port connection (1/32).
	mux_32 datamux({31'b0, WrMemToReg}, WrALUout, WrDataOut, busW);
	                                                            |
xmelab: *W,CUVMPW (./cpu.v,136|61): port sizes differ in port connection (1/32).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                   |
xmelab: *W,CUVMPW (./cpu.v,137|132): port sizes differ in port connection (1/5).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                                  |
xmelab: *W,CUVMPW (./cpu.v,137|147): port sizes differ in port connection (1/5).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                                                        |
xmelab: *W,CUVMPW (./cpu.v,137|169): port sizes differ in port connection (5/1).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                                                                     |
xmelab: *W,CUVMPW (./cpu.v,137|182): port sizes differ in port connection (5/1).
	set_if_eq eqRsEX (.x(Rs), .y(EXrw), .z(dhaz[3]));
	                      |
xmelab: *W,CUVMPW (./stall.v,18|23): port sizes differ in port connection (1/6).
	set_if_eq eqRsEX (.x(Rs), .y(EXrw), .z(dhaz[3]));
	                                |
xmelab: *W,CUVMPW (./stall.v,18|33): port sizes differ in port connection (5/6).
	set_if_eq eqRsWr (.x(Rs), .y(Wrrw), .z(dhaz[2]));
	                      |
xmelab: *W,CUVMPW (./stall.v,19|23): port sizes differ in port connection (1/6).
	set_if_eq eqRsWr (.x(Rs), .y(Wrrw), .z(dhaz[2]));
	                                |
xmelab: *W,CUVMPW (./stall.v,19|33): port sizes differ in port connection (5/6).
	set_if_eq eqRtEX (.x(IDRt), .y(EXrw), .z(dhaz[1]));
	                        |
xmelab: *W,CUVMPW (./stall.v,20|25): port sizes differ in port connection (1/6).
	set_if_eq eqRtEX (.x(IDRt), .y(EXrw), .z(dhaz[1]));
	                                  |
xmelab: *W,CUVMPW (./stall.v,20|35): port sizes differ in port connection (5/6).
	set_if_eq eqRtWr (.x(IDRt), .y(Wrrw), .z(dhaz[0]));
	                        |
xmelab: *W,CUVMPW (./stall.v,21|25): port sizes differ in port connection (1/6).
	set_if_eq eqRtWr (.x(IDRt), .y(Wrrw), .z(dhaz[0]));
	                                  |
xmelab: *W,CUVMPW (./stall.v,21|35): port sizes differ in port connection (5/6).
	d_mem datamem(.clk(clk), .data_in(busB), .data_out(DataOut), .adr(ALUout), .WrEn(MemMemWr));
	                                     |
xmelab: *W,CUVMPW (./cpu.v,134|38): port sizes differ in port connection (1/32).
	mux_32 datamux({31'b0, WrMemToReg}, WrALUout, WrDataOut, busW);
	                                                            |
xmelab: *W,CUVMPW (./cpu.v,136|61): port sizes differ in port connection (1/32).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                   |
xmelab: *W,CUVMPW (./cpu.v,137|132): port sizes differ in port connection (1/5).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                                  |
xmelab: *W,CUVMPW (./cpu.v,137|147): port sizes differ in port connection (1/5).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                                                        |
xmelab: *W,CUVMPW (./cpu.v,137|169): port sizes differ in port connection (5/1).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                                                                     |
xmelab: *W,CUVMPW (./cpu.v,137|182): port sizes differ in port connection (5/1).
	set_if_eq eqRsEX (.x(Rs), .y(EXrw), .z(dhaz[3]));
	                      |
xmelab: *W,CUVMPW (./stall.v,18|23): port sizes differ in port connection (1/6).
	set_if_eq eqRsEX (.x(Rs), .y(EXrw), .z(dhaz[3]));
	                                |
xmelab: *W,CUVMPW (./stall.v,18|33): port sizes differ in port connection (5/6).
	set_if_eq eqRsWr (.x(Rs), .y(Wrrw), .z(dhaz[2]));
	                      |
xmelab: *W,CUVMPW (./stall.v,19|23): port sizes differ in port connection (1/6).
	set_if_eq eqRsWr (.x(Rs), .y(Wrrw), .z(dhaz[2]));
	                                |
xmelab: *W,CUVMPW (./stall.v,19|33): port sizes differ in port connection (5/6).
	set_if_eq eqRtEX (.x(IDRt), .y(EXrw), .z(dhaz[1]));
	                        |
xmelab: *W,CUVMPW (./stall.v,20|25): port sizes differ in port connection (1/6).
	set_if_eq eqRtEX (.x(IDRt), .y(EXrw), .z(dhaz[1]));
	                                  |
xmelab: *W,CUVMPW (./stall.v,20|35): port sizes differ in port connection (5/6).
	set_if_eq eqRtWr (.x(IDRt), .y(Wrrw), .z(dhaz[0]));
	                        |
xmelab: *W,CUVMPW (./stall.v,21|25): port sizes differ in port connection (1/6).
	set_if_eq eqRtWr (.x(IDRt), .y(Wrrw), .z(dhaz[0]));
	                                  |
xmelab: *W,CUVMPW (./stall.v,21|35): port sizes differ in port connection (5/6).
	d_mem datamem(.clk(clk), .data_in(busB), .data_out(DataOut), .adr(ALUout), .WrEn(MemMemWr));
	                                     |
xmelab: *W,CUVMPW (./cpu.v,134|38): port sizes differ in port connection (1/32).
	mux_32 datamux({31'b0, WrMemToReg}, WrALUout, WrDataOut, busW);
	                                                            |
xmelab: *W,CUVMPW (./cpu.v,136|61): port sizes differ in port connection (1/32).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                   |
xmelab: *W,CUVMPW (./cpu.v,137|132): port sizes differ in port connection (1/5).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                                  |
xmelab: *W,CUVMPW (./cpu.v,137|147): port sizes differ in port connection (1/5).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                                                        |
xmelab: *W,CUVMPW (./cpu.v,137|169): port sizes differ in port connection (5/1).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                                                                     |
xmelab: *W,CUVMPW (./cpu.v,137|182): port sizes differ in port connection (5/1).
	set_if_eq eqRsEX (.x(Rs), .y(EXrw), .z(dhaz[3]));
	                      |
xmelab: *W,CUVMPW (./stall.v,18|23): port sizes differ in port connection (1/6).
	set_if_eq eqRsEX (.x(Rs), .y(EXrw), .z(dhaz[3]));
	                                |
xmelab: *W,CUVMPW (./stall.v,18|33): port sizes differ in port connection (5/6).
	set_if_eq eqRsWr (.x(Rs), .y(Wrrw), .z(dhaz[2]));
	                      |
xmelab: *W,CUVMPW (./stall.v,19|23): port sizes differ in port connection (1/6).
	set_if_eq eqRsWr (.x(Rs), .y(Wrrw), .z(dhaz[2]));
	                                |
xmelab: *W,CUVMPW (./stall.v,19|33): port sizes differ in port connection (5/6).
	set_if_eq eqRtEX (.x(IDRt), .y(EXrw), .z(dhaz[1]));
	                        |
xmelab: *W,CUVMPW (./stall.v,20|25): port sizes differ in port connection (1/6).
	set_if_eq eqRtEX (.x(IDRt), .y(EXrw), .z(dhaz[1]));
	                                  |
xmelab: *W,CUVMPW (./stall.v,20|35): port sizes differ in port connection (5/6).
	set_if_eq eqRtWr (.x(IDRt), .y(Wrrw), .z(dhaz[0]));
	                        |
xmelab: *W,CUVMPW (./stall.v,21|25): port sizes differ in port connection (1/6).
	set_if_eq eqRtWr (.x(IDRt), .y(Wrrw), .z(dhaz[0]));
	                                  |
xmelab: *W,CUVMPW (./stall.v,21|35): port sizes differ in port connection (5/6).
	Building instance overlay tables: .................... Done
	Generating native compiled code:
		worklib.nostalls_tb:v <0x0061df30>
			streams:   3, words:  1257
		worklib.sram:v <0x6a4e80b7>
			streams:  13, words: 15004
		worklib.syncram:v <0x5b1f0f5d>
			streams:  13, words: 15081
	Building instance specific data structures.
	d_mem datamem(.clk(clk), .data_in(busB), .data_out(DataOut), .adr(ALUout), .WrEn(MemMemWr));
	                                     |
xmelab: *W,CSINFI (./cpu.v,134|38): implicit wire has no fanin (unsigned_sum_tb.cpu1.busB).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                                  |
xmelab: *W,CSINFI (./cpu.v,137|147): implicit wire has no fanin (unsigned_sum_tb.cpu1.Memrw).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                   |
xmelab: *W,CSINFI (./cpu.v,137|132): implicit wire has no fanin (unsigned_sum_tb.cpu1.EXrw).
   or_gate orltorz(equal, sign, ltorz);
                             |
xmelab: *W,CSINFI (./cpu.v,386|29): implicit wire has no fanin (unsigned_sum_tb.cpu1.br.sign).
	d_mem datamem(.clk(clk), .data_in(busB), .data_out(DataOut), .adr(ALUout), .WrEn(MemMemWr));
	                                     |
xmelab: *W,CSINFI (./cpu.v,134|38): implicit wire has no fanin (sort_correct_branch_tb.cpu1.busB).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                                  |
xmelab: *W,CSINFI (./cpu.v,137|147): implicit wire has no fanin (sort_correct_branch_tb.cpu1.Memrw).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                   |
xmelab: *W,CSINFI (./cpu.v,137|132): implicit wire has no fanin (sort_correct_branch_tb.cpu1.EXrw).
   or_gate orltorz(equal, sign, ltorz);
                             |
xmelab: *W,CSINFI (./cpu.v,386|29): implicit wire has no fanin (sort_correct_branch_tb.cpu1.br.sign).
	d_mem datamem(.clk(clk), .data_in(busB), .data_out(DataOut), .adr(ALUout), .WrEn(MemMemWr));
	                                     |
xmelab: *W,CSINFI (./cpu.v,134|38): implicit wire has no fanin (bills_branch_tb.cpu1.busB).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                                  |
xmelab: *W,CSINFI (./cpu.v,137|147): implicit wire has no fanin (bills_branch_tb.cpu1.Memrw).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                   |
xmelab: *W,CSINFI (./cpu.v,137|132): implicit wire has no fanin (bills_branch_tb.cpu1.EXrw).
   or_gate orltorz(equal, sign, ltorz);
                             |
xmelab: *W,CSINFI (./cpu.v,386|29): implicit wire has no fanin (bills_branch_tb.cpu1.br.sign).
	d_mem datamem(.clk(clk), .data_in(busB), .data_out(DataOut), .adr(ALUout), .WrEn(MemMemWr));
	                                     |
xmelab: *W,CSINFI (./cpu.v,134|38): implicit wire has no fanin (nostalls_tb.cpu1.busB).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                                  |
xmelab: *W,CSINFI (./cpu.v,137|147): implicit wire has no fanin (nostalls_tb.cpu1.Memrw).
	stall st (.IDfunc(IDfunc), .EXfunc(EXfunc), .IDRegWr(IDRegWr), .MemRegWr(MemRegWr), .EXRegWr(EXRegWr), .WrRegWr(WrRegWr), .EXrw(EXrw), .Memrw(Memrw), .Wrrw(WrRw), .Rs(Rs), .IDRt(IDRt), .IFstall(IFstall), .IDstall(IDstall));
	                                                                                                                                   |
xmelab: *W,CSINFI (./cpu.v,137|132): implicit wire has no fanin (nostalls_tb.cpu1.EXrw).
   or_gate orltorz(equal, sign, ltorz);
                             |
xmelab: *W,CSINFI (./cpu.v,386|29): implicit wire has no fanin (nostalls_tb.cpu1.br.sign).
	Loading native compiled code:     .................... Done
	Design hierarchy summary:
		                 Instances  Unique
		Modules:             10446      46
		Registers:            4829      84
		Scalar wires:         9681       -
		Expanded wires:       5460     244
		Vectored wires:        410       -
		Always blocks:        4541      12
		Initial blocks:         68      20
		Cont. assignments:     128      67
		Pseudo assignments:     60      18
	Writing initial simulation snapshot: worklib.pc_branch:v
xmsim: *W,DSEM2009: This SystemVerilog design is simulated as per IEEE 1800-2009 SystemVerilog simulation semantics. Use -disable_sem2009 option for turning off SV 2009 simulation semantics.

-------------------------------------
Relinquished control to SimVision...
xcelium> 
xcelium> source /vol/cadence2018/XCELIUM1809/tools/xcelium/files/xmsimrc
xcelium> ^C
xcelium> exit
TOOL:	xrun(64)	18.09-s011: Exiting on Dec 06, 2021 at 20:53:09 CST  (total: 00:00:07)
